# source: generated by Claude.ai
# run in rails bash shell with:
#       rails test test/models/conversation_test.rb

require "test_helper"

class ConversationTest < ActiveSupport::TestCase
  def setup
    @initiator = User.create!(
      username: "initiator_user",
      password: "password123"
    )
    
    @expert = User.create!(
      username: "expert_user",
      password: "password123"
    )
  end

  test "should create valid conversation" do
    conversation = Conversation.new(
      title: "Need help with Rails",
      initiator: @initiator
    )
    assert conversation.valid?
    assert conversation.save
  end

  test "should require title" do
    conversation = Conversation.new(initiator: @initiator)
    assert_not conversation.valid?
    assert_includes conversation.errors[:title], "can't be blank"
  end

  test "should require initiator" do
    conversation = Conversation.new(title: "Test")
    assert_not conversation.valid?
    assert_includes conversation.errors[:initiator], "must exist"
  end

  test "should have default status of waiting" do
    conversation = Conversation.create!(
      title: "Test conversation",
      initiator: @initiator
    )
    assert_equal "waiting", conversation.status
  end

  test "should allow valid status values" do
    conversation = Conversation.create!(
      title: "Test",
      initiator: @initiator
    )
    
    %w[waiting active resolved].each do |status|
      conversation.status = status
      assert conversation.valid?, "#{status} should be a valid status"
    end
  end

  test "should not allow invalid status" do
    conversation = Conversation.new(
      title: "Test",
      initiator: @initiator,
      status: "invalid_status"
    )
    assert_not conversation.valid?
    assert_includes conversation.errors[:status], "is not included in the list"
  end

  test "assigned_expert should be optional" do
    conversation = Conversation.new(
      title: "Test",
      initiator: @initiator,
      assigned_expert: nil
    )
    assert conversation.valid?
  end

  test "should assign expert and change status to active" do
    conversation = Conversation.create!(
      title: "Test",
      initiator: @initiator
    )
    
    assert_equal "waiting", conversation.status
    assert_nil conversation.assigned_expert
    
    conversation.assign_expert(@expert)
    conversation.reload
    
    assert_equal @expert, conversation.assigned_expert
    assert_equal "active", conversation.status
  end

  test "should unassign expert and change status to waiting" do
    conversation = Conversation.create!(
      title: "Test",
      initiator: @initiator,
      assigned_expert: @expert,
      status: "active"
    )
    
    assert_equal @expert, conversation.assigned_expert
    assert_equal "active", conversation.status
    
    conversation.unassign_expert
    conversation.reload
    
    assert_nil conversation.assigned_expert
    assert_equal "waiting", conversation.status
  end

  test "should mark as resolved" do
    conversation = Conversation.create!(
      title: "Test",
      initiator: @initiator,
      status: "active"
    )
    
    conversation.mark_resolved
    conversation.reload
    
    assert_equal "resolved", conversation.status
  end

  test "should have messages association" do
    conversation = Conversation.create!(
      title: "Test",
      initiator: @initiator
    )
    
    assert_respond_to conversation, :messages
  end

  test "should have expert_assignments association" do
    conversation = Conversation.create!(
      title: "Test",
      initiator: @initiator
    )
    
    assert_respond_to conversation, :expert_assignments
  end

  test "destroying conversation destroys associated messages" do
    conversation = Conversation.create!(
      title: "Test",
      initiator: @initiator
    )
    
    # We'll uncomment this after creating Message model
    message = Message.create!(
      conversation: conversation,
      sender: @initiator,
      sender_role: "initiator",
      content: "Test message"
    )
    message_id = message.id
    
    conversation.destroy
    
    assert_nil Message.find_by(id: message_id)
  end

  test "destroying conversation destroys associated expert_assignments" do
    conversation = Conversation.create!(
      title: "Test",
      initiator: @initiator
    )
    
    assignment = ExpertAssignment.create!(
      conversation: conversation,
      expert: @expert
    )
    assignment_id = assignment.id
    
    conversation.destroy
    
    assert_nil ExpertAssignment.find_by(id: assignment_id)
  end

  test "belongs to initiator" do
    conversation = Conversation.create!(
      title: "Test",
      initiator: @initiator
    )
    
    assert_equal @initiator, conversation.initiator
  end

  test "belongs to assigned_expert" do
    conversation = Conversation.create!(
      title: "Test",
      initiator: @initiator,
      assigned_expert: @expert
    )
    
    assert_equal @expert, conversation.assigned_expert
  end

  test "can create conversation without assigned expert" do
    conversation = Conversation.create!(
      title: "Test",
      initiator: @initiator
    )
    
    assert_nil conversation.assigned_expert
    assert conversation.persisted?
  end

  test "last_message_at should be nullable" do
    conversation = Conversation.create!(
      title: "Test",
      initiator: @initiator
    )
    
    assert_nil conversation.last_message_at
  end

  test "can update last_message_at using touch" do
    conversation = Conversation.create!(
      title: "Test",
      initiator: @initiator
    )
    
    assert_nil conversation.last_message_at
    
    conversation.touch(:last_message_at)
    conversation.reload
    
    assert_not_nil conversation.last_message_at
  end
end