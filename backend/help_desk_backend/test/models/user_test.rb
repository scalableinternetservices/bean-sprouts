# source: generated by Claude.ai
# run in rails bash shell with:
#       rails test test/models/user_test.rb

require "test_helper"

class UserTest < ActiveSupport::TestCase
  test "valid user" do
    user = User.new(username: "testuser", password: "password123")
    assert user.valid?
  end
  
  test "invalid without username" do
    user = User.new(password: "password123")
    assert_not user.valid?
    assert_includes user.errors[:username], "can't be blank"
  end
  
  test "invalid with short username" do
    user = User.new(username: "ab", password: "password123")
    assert_not user.valid?
    assert_includes user.errors[:username], "is too short (minimum is 3 characters)"
  end
  
  test "invalid with long username" do
    user = User.new(username: "a" * 51, password: "password123")
    assert_not user.valid?
    assert_includes user.errors[:username], "is too long (maximum is 50 characters)"
  end
  
  test "invalid without password" do
    user = User.new(username: "testuser")
    assert_not user.valid?
  end
  
  test "invalid with short password" do
    user = User.new(username: "testuser", password: "12345")
    assert_not user.valid?
    assert_includes user.errors[:password], "is too short (minimum is 6 characters)"
  end
  
  test "username must be unique" do
    User.create!(username: "testuser", password: "password123")
    duplicate = User.new(username: "testuser", password: "password123")
    assert_not duplicate.valid?
    assert_includes duplicate.errors[:username], "has already been taken"
  end
  
  test "username is case insensitive" do
    User.create!(username: "TestUser", password: "password123")
    duplicate = User.new(username: "testuser", password: "password123")
    assert_not duplicate.valid?
    assert_includes duplicate.errors[:username], "has already been taken"
  end
  
  test "username is downcased before save" do
    user = User.create!(username: "TestUser", password: "password123")
    assert_equal "testuser", user.username
  end
  
  test "username whitespace is stripped before save" do
    user = User.create!(username: "  testuser  ", password: "password123")
    assert_equal "testuser", user.username
  end
  
  test "password authentication" do
    user = User.create!(username: "testuser", password: "password123")
    assert user.authenticate("password123")
    assert_not user.authenticate("wrongpassword")
  end
  
  test "can update username without providing password" do
    user = User.create!(username: "oldname", password: "password123")
    assert user.update(username: "newname")
    assert_equal "newname", user.username
  end
  
  test "can update password" do
    user = User.create!(username: "testuser", password: "oldpassword")
    assert user.update(password: "newpassword123")
    assert user.authenticate("newpassword123")
    assert_not user.authenticate("oldpassword")
  end
  
  test "update_last_active! updates last_active_at timestamp" do
    user = User.create!(username: "testuser", password: "password123")
    original_time = user.last_active_at
    
    # Wait a moment to ensure time difference
    sleep 0.1
    
    user.update_last_active!
    user.reload
    
    assert_not_nil user.last_active_at
    assert user.last_active_at > original_time if original_time
  end
  
  test "has conversations_as_initiator association" do
    user = User.create!(username: "testuser", password: "password123")
    assert_respond_to user, :conversations_as_initiator
  end
  
  test "has conversations_as_expert association" do
    user = User.create!(username: "testuser", password: "password123")
    assert_respond_to user, :conversations_as_expert
  end
  
  test "has messages association" do
    user = User.create!(username: "testuser", password: "password123")
    assert_respond_to user, :messages
  end
  
  test "has expert_profile association" do
    user = User.create!(username: "testuser", password: "password123")
    assert_respond_to user, :expert_profile
  end
  
  test "destroying user destroys initiated conversations" do
    initiator = User.create!(username: "initiator", password: "password123")
    conversation = Conversation.create!(
      title: "Test conversation",
      initiator: initiator
    )
    
    conversation_id = conversation.id
    initiator.destroy
    
    assert_nil Conversation.find_by(id: conversation_id)
  end
  
  test "destroying user nullifies assigned expert in conversations" do
    initiator = User.create!(username: "initiator", password: "password123")
    expert = User.create!(username: "expert", password: "password123")
    conversation = Conversation.create!(
      title: "Test conversation",
      initiator: initiator,
      assigned_expert: expert,
      status: 'active'
    )
    
    expert.destroy
    conversation.reload
    
    assert_nil conversation.assigned_expert_id
    assert conversation.persisted? # Conversation still exists
  end
  
  test "expert? returns false when user has no expert profile" do
    user = User.create!(username: "testuser", password: "password123")
    assert_not user.expert?
  end
  
  test "expert? returns true when user has expert profile" do
    user = User.create!(username: "expert", password: "password123")
    user.create_expert_profile(bio: "I'm an expert")
    assert user.expert?
  end
end