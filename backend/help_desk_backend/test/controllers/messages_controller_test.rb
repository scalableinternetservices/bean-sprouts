# source: generated by Claude.ai
# run in rails bash shell with:
#       rails test test/controllers/messages_controller_test.rb

require "test_helper"

class MessagesControllerTest < ActionDispatch::IntegrationTest
  def setup
    @user = User.create!(username: "testuser", password: "password123")
    @expert = User.create!(username: "expertuser", password: "password123")
    @token = JwtService.encode(@user)
    @expert_token = JwtService.encode(@expert)
    
    @conversation = Conversation.create!(
      title: "Test Conversation",
      initiator: @user,
      status: "waiting"
    )
  end

  # Index tests
  test "GET /conversations/:id/messages returns messages for conversation" do
    message1 = Message.create!(
      conversation: @conversation,
      sender: @user,
      sender_role: "initiator",
      content: "First message"
    )
    
    message2 = Message.create!(
      conversation: @conversation,
      sender: @user,
      sender_role: "initiator",
      content: "Second message"
    )
    
    get "/conversations/#{@conversation.id}/messages",
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    assert_equal 2, json_response.length
    assert_equal "First message", json_response[0]["content"]
    assert_equal "Second message", json_response[1]["content"]
  end

  test "GET /conversations/:id/messages requires authentication" do
    get "/conversations/#{@conversation.id}/messages"
    assert_response :unauthorized
  end

  # Piazza
  # test "GET /conversations/:id/messages returns 404 for conversation user doesn't own" do
  #   other_user = User.create!(username: "otheruser", password: "password123")
  #   other_conversation = Conversation.create!(
  #     title: "Other Conversation",
  #     initiator: other_user,
  #     status: "waiting"
  #   )
    
  #   get "/conversations/#{other_conversation.id}/messages",
  #       headers: { "Authorization" => "Bearer #{@token}" }
    
  #   assert_response :not_found
  # end

  test "GET /conversations/:id/messages returns messages in chronological order" do
    message2 = Message.create!(
      conversation: @conversation,
      sender: @user,
      sender_role: "initiator",
      content: "Second",
      created_at: 2.minutes.ago
    )
    
    message1 = Message.create!(
      conversation: @conversation,
      sender: @user,
      sender_role: "initiator",
      content: "First",
      created_at: 3.minutes.ago
    )
    
    get "/conversations/#{@conversation.id}/messages",
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    assert_equal "First", json_response[0]["content"]
    assert_equal "Second", json_response[1]["content"]
  end

  # Create tests
  test "POST /messages creates a new message" do
    assert_difference 'Message.count', 1 do
      post "/messages",
           params: { conversationId: @conversation.id, content: "Hello!" },
           headers: { "Authorization" => "Bearer #{@token}" },
           as: :json
    end
    
    assert_response :created
    json_response = JSON.parse(response.body)
    
    assert_equal "Hello!", json_response["content"]
    assert_equal @user.id.to_s, json_response["senderId"]
    assert_equal "initiator", json_response["senderRole"]
  end

  test "POST /messages automatically sets sender_role to initiator for conversation creator" do
    post "/messages",
         params: { conversationId: @conversation.id, content: "Test" },
         headers: { "Authorization" => "Bearer #{@token}" },
         as: :json
    
    assert_response :created
    json_response = JSON.parse(response.body)
    
    assert_equal "initiator", json_response["senderRole"]
  end

  test "POST /messages automatically sets sender_role to expert for assigned expert" do
    @conversation.assign_expert(@expert)
    
    post "/messages",
         params: { conversationId: @conversation.id, content: "I can help" },
         headers: { "Authorization" => "Bearer #{@expert_token}" },
         as: :json
    
    assert_response :created
    json_response = JSON.parse(response.body)
    
    assert_equal "expert", json_response["senderRole"]
  end

  test "POST /messages requires authentication" do
    post "/messages",
         params: { conversationId: @conversation.id, content: "Test" },
         as: :json
    
    assert_response :unauthorized
  end

  test "POST /messages requires content" do
    post "/messages",
         params: { conversationId: @conversation.id },
         headers: { "Authorization" => "Bearer #{@token}" },
         as: :json
    
    assert_response :unprocessable_entity
  end

  test "POST /messages returns 404 for conversation user doesn't own" do
    other_user = User.create!(username: "otheruser", password: "password123")
    other_conversation = Conversation.create!(
      title: "Other Conversation",
      initiator: other_user,
      status: "waiting"
    )
    
    post "/messages",
         params: { conversationId: other_conversation.id, content: "Test" },
         headers: { "Authorization" => "Bearer #{@token}" },
         as: :json
    
    assert_response :not_found
  end

  test "POST /messages updates conversation last_message_at" do
    @conversation.update(last_message_at: nil)
    
    post "/messages",
         params: { conversationId: @conversation.id, content: "Test" },
         headers: { "Authorization" => "Bearer #{@token}" },
         as: :json
    
    @conversation.reload
    assert_not_nil @conversation.last_message_at
  end

  # Mark as read tests
  test "PUT /messages/:id/read marks message as read" do
    # Expert sends message
    @conversation.assign_expert(@expert)
    message = Message.create!(
      conversation: @conversation,
      sender: @expert,
      sender_role: "expert",
      content: "Expert reply"
    )
    
    assert_equal false, message.is_read
    
    # User marks it as read
    put "/messages/#{message.id}/read",
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :ok
    
    message.reload
    assert_equal true, message.is_read
  end

  test "PUT /messages/:id/read requires authentication" do
    message = Message.create!(
      conversation: @conversation,
      sender: @user,
      sender_role: "initiator",
      content: "Test"
    )
    
    put "/messages/#{message.id}/read"
    assert_response :unauthorized
  end

  test "PUT /messages/:id/read fails when marking own message" do
    message = Message.create!(
      conversation: @conversation,
      sender: @user,
      sender_role: "initiator",
      content: "My message"
    )
    
    put "/messages/#{message.id}/read",
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :forbidden
    json_response = JSON.parse(response.body)
    assert_equal "Cannot mark your own messages as read", json_response["error"]
  end

  test "PUT /messages/:id/read returns 404 for message in conversation user doesn't own" do
    other_user = User.create!(username: "otheruser", password: "password123")
    other_conversation = Conversation.create!(
      title: "Other",
      initiator: other_user
    )
    message = Message.create!(
      conversation: other_conversation,
      sender: other_user,
      sender_role: "initiator",
      content: "Test"
    )
    
    put "/messages/#{message.id}/read",
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :not_found
  end

  # Response format tests
  test "message response includes all required fields" do
    message = Message.create!(
      conversation: @conversation,
      sender: @user,
      sender_role: "initiator",
      content: "Test message"
    )
    
    get "/conversations/#{@conversation.id}/messages",
        headers: { "Authorization" => "Bearer #{@token}" }
    
    json_response = JSON.parse(response.body).first
    
    assert_not_nil json_response["id"]
    assert_not_nil json_response["conversationId"]
    assert_not_nil json_response["senderId"]
    assert_not_nil json_response["senderUsername"]
    assert_not_nil json_response["senderRole"]
    assert_not_nil json_response["content"]
    assert_not_nil json_response["timestamp"]
    assert_not_nil json_response["isRead"]
  end

  test "message timestamp is in ISO 8601 format" do
    message = Message.create!(
      conversation: @conversation,
      sender: @user,
      sender_role: "initiator",
      content: "Test"
    )
    
    get "/conversations/#{@conversation.id}/messages",
        headers: { "Authorization" => "Bearer #{@token}" }
    
    json_response = JSON.parse(response.body).first
    timestamp = json_response["timestamp"]
    
    assert_nothing_raised do
      Time.iso8601(timestamp)
    end
  end
end
