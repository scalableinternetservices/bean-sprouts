# source: generated by Claude.ai
# run in rails bash shell with:
#       rails test test/controllers/updates_controller_test.rb

require "test_helper"

class UpdatesControllerTest < ActionDispatch::IntegrationTest
  def setup
    @user = User.create!(username: "testuser", password: "password123")
    @expert = User.create!(username: "expertuser", password: "password123")
    @expert.create_expert_profile(bio: "I'm an expert")
    @token = JwtService.encode(@user)
    @expert_token = JwtService.encode(@expert)
    
    @conversation = Conversation.create!(
      title: "Test Conversation",
      initiator: @user,
      status: "waiting"
    )
    
    @message = Message.create!(
      conversation: @conversation,
      sender: @user,
      sender_role: "initiator",
      content: "Test message"
    )
  end

  # Conversation updates tests
  test "GET /api/conversations/updates returns user's conversations" do
    get "/api/conversations/updates",
        params: { userId: @user.id },
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    assert_equal 1, json_response.length
    assert_equal @conversation.id.to_s, json_response[0]["id"]
  end

  test "GET /api/conversations/updates requires authentication" do
    get "/api/conversations/updates",
        params: { userId: @user.id }
    
    assert_response :unauthorized
  end

  test "GET /api/conversations/updates prevents accessing other user's updates" do
    other_user = User.create!(username: "otheruser", password: "password123")
    
    get "/api/conversations/updates",
        params: { userId: other_user.id },
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :unauthorized
  end

  test "GET /api/conversations/updates filters by since timestamp" do
    # Update setup conversation to be old
    @conversation.update_column(:updated_at, 3.hours.ago)
    
    # Create old conversation with explicit timestamp
    old_conv = Conversation.create!(
      title: "Old Conversation",
      initiator: @user,
      status: "waiting"
    )
    old_conv.update_column(:updated_at, 2.hours.ago)
    
    # Mark boundary
    since_time = 1.hour.ago
    
    # Small delay to ensure timestamp difference
    sleep 0.01
    
    # Create new conversation
    new_conv = Conversation.create!(
      title: "New Conversation",
      initiator: @user,
      status: "waiting"
    )
    
    # Request updates since boundary
    get "/api/conversations/updates",
        params: { userId: @user.id, since: since_time.iso8601 },
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    # Should only get new conversation
    assert_equal 1, json_response.length
    assert_equal new_conv.id.to_s, json_response[0]["id"]
  end

  test "GET /api/conversations/updates returns all without since parameter" do
    conv2 = Conversation.create!(
      title: "Another Conversation",
      initiator: @user,
      status: "waiting"
    )
    
    get "/api/conversations/updates",
        params: { userId: @user.id },
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    assert_equal 2, json_response.length
  end

  test "GET /api/conversations/updates returns bad request for invalid timestamp" do
    get "/api/conversations/updates",
        params: { userId: @user.id, since: "invalid-timestamp" },
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :bad_request
    json_response = JSON.parse(response.body)
    assert_equal "Invalid timestamp format", json_response["error"]
  end

  test "GET /api/conversations/updates includes conversations where user is expert" do
    @conversation.assign_expert(@user)
    
    get "/api/conversations/updates",
        params: { userId: @user.id },
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    assert_equal 1, json_response.length
  end

  # Message updates tests
  test "GET /api/messages/updates returns messages from user's conversations" do
    get "/api/messages/updates",
        params: { userId: @user.id },
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    assert_equal 1, json_response.length
    assert_equal @message.id.to_s, json_response[0]["id"]
  end

  test "GET /api/messages/updates requires authentication" do
    get "/api/messages/updates",
        params: { userId: @user.id }
    
    assert_response :unauthorized
  end

  test "GET /api/messages/updates prevents accessing other user's messages" do
    other_user = User.create!(username: "otheruser", password: "password123")
    
    get "/api/messages/updates",
        params: { userId: other_user.id },
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :unauthorized
  end

  test "GET /api/messages/updates filters by since timestamp" do
    # Update setup message to be old
    @message.update_column(:created_at, 3.hours.ago)
    
    # Create old message with explicit timestamp
    old_message = Message.create!(
      conversation: @conversation,
      sender: @user,
      sender_role: "initiator",
      content: "Old message"
    )
    old_message.update_column(:created_at, 2.hours.ago)
    
    # Mark boundary
    since_time = 1.hour.ago
    
    # Small delay
    sleep 0.01
    
    # Create new message
    new_message = Message.create!(
      conversation: @conversation,
      sender: @user,
      sender_role: "initiator",
      content: "New message"
    )
    
    # Request updates since boundary
    get "/api/messages/updates",
        params: { userId: @user.id, since: since_time.iso8601 },
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    # Should only get new message
    assert_equal 1, json_response.length
    assert_equal new_message.id.to_s, json_response[0]["id"]
  end

  test "GET /api/messages/updates returns messages in chronological order" do
    # Use update_column to set explicit timestamps
    @message.update_column(:created_at, 15.minutes.ago)
    
    message2 = Message.create!(
      conversation: @conversation,
      sender: @user,
      sender_role: "initiator",
      content: "Second message"
    )
    message2.update_column(:created_at, 10.minutes.ago)
    
    message3 = Message.create!(
      conversation: @conversation,
      sender: @user,
      sender_role: "initiator",
      content: "Third message"
    )
    message3.update_column(:created_at, 5.minutes.ago)
    
    get "/api/messages/updates",
        params: { userId: @user.id },
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    # Should be in order: oldest first
    assert_equal "Test message", json_response[0]["content"]
    assert_equal "Second message", json_response[1]["content"]
    assert_equal "Third message", json_response[2]["content"]
  end

  test "GET /api/messages/updates returns bad request for invalid timestamp" do
    get "/api/messages/updates",
        params: { userId: @user.id, since: "not-a-timestamp" },
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :bad_request
  end

  test "GET /api/messages/updates only returns messages from user's conversations" do
    # Create another user and their conversation
    other_user = User.create!(username: "otheruser", password: "password123")
    other_conversation = Conversation.create!(
      title: "Other Conversation",
      initiator: other_user,
      status: "waiting"
    )
    other_message = Message.create!(
      conversation: other_conversation,
      sender: other_user,
      sender_role: "initiator",
      content: "Other message"
    )
    
    get "/api/messages/updates",
        params: { userId: @user.id },
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    # Should not include other user's message
    message_ids = json_response.map { |m| m["id"] }
    assert_not_includes message_ids, other_message.id.to_s
  end

  # Expert queue updates tests
  test "GET /api/expert-queue/updates returns expert queue" do
    waiting_conv = Conversation.create!(
      title: "Waiting Conversation",
      initiator: @user,
      status: "waiting"
    )
    
    assigned_conv = Conversation.create!(
      title: "Assigned Conversation",
      initiator: @user,
      status: "active",
      assigned_expert: @expert
    )
    
    get "/api/expert-queue/updates",
        params: { expertId: @expert.id },
        headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    # Response is an array with one object containing both queues
    assert_equal 1, json_response.length
    assert_not_nil json_response[0]["waitingConversations"]
    assert_not_nil json_response[0]["assignedConversations"]
  end

  test "GET /api/expert-queue/updates requires authentication" do
    get "/api/expert-queue/updates",
        params: { expertId: @expert.id }
    
    assert_response :unauthorized
  end

  test "GET /api/expert-queue/updates prevents accessing other expert's queue" do
    other_expert = User.create!(username: "otherexpert", password: "password123")
    
    get "/api/expert-queue/updates",
        params: { expertId: other_expert.id },
        headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :unauthorized
  end

  test "GET /api/expert-queue/updates requires expert profile" do
    # Create user and destroy expert profile
    non_expert = User.create!(username: "nonexpert", password: "password123")
    ExpertProfile.find_by(user_id: non_expert.id)&.destroy
    non_expert_token = JwtService.encode(non_expert)
    
    get "/api/expert-queue/updates",
        params: { expertId: non_expert.id },
        headers: { "Authorization" => "Bearer #{non_expert_token}" }
    
    assert_response :forbidden
  end

  test "GET /api/expert-queue/updates filters by since timestamp" do
    # Update setup conversation to be old
    @conversation.update_column(:updated_at, 3.hours.ago)
    
    # Create old waiting conversation
    old_waiting = Conversation.create!(
      title: "Old Waiting",
      initiator: @user,
      status: "waiting"
    )
    old_waiting.update_column(:updated_at, 2.hours.ago)
    
    # Mark boundary
    since_time = 1.hour.ago
    
    # Small delay
    sleep 0.01
    
    # Create new waiting conversation
    new_waiting = Conversation.create!(
      title: "New Waiting",
      initiator: @user,
      status: "waiting"
    )
    
    get "/api/expert-queue/updates",
        params: { expertId: @expert.id, since: since_time.iso8601 },
        headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    waiting_conversations = json_response[0]["waitingConversations"]
    
    # Should only get new conversation
    assert_equal 1, waiting_conversations.length
    assert_equal new_waiting.id.to_s, waiting_conversations[0]["id"]
  end

  test "GET /api/expert-queue/updates returns bad request for invalid timestamp" do
    get "/api/expert-queue/updates",
        params: { expertId: @expert.id, since: "bad-timestamp" },
        headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :bad_request
  end

  test "GET /api/expert-queue/updates includes waiting and assigned conversations" do
    waiting_conv = Conversation.create!(
      title: "Waiting",
      initiator: @user,
      status: "waiting"
    )
    
    assigned_conv = Conversation.create!(
      title: "Assigned",
      initiator: @user,
      status: "active",
      assigned_expert: @expert
    )
    
    get "/api/expert-queue/updates",
        params: { expertId: @expert.id },
        headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    waiting = json_response[0]["waitingConversations"]
    assigned = json_response[0]["assignedConversations"]
    
    assert waiting.any? { |c| c["id"] == waiting_conv.id.to_s }
    assert assigned.any? { |c| c["id"] == assigned_conv.id.to_s }
  end

  # Response format tests
  test "conversation updates include all required fields" do
    get "/api/conversations/updates",
        params: { userId: @user.id },
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body).first
    
    assert_not_nil json_response["id"]
    assert_not_nil json_response["title"]
    assert_not_nil json_response["status"]
    assert_not_nil json_response["questionerId"]
    assert_not_nil json_response["questionerUsername"]
    assert_not_nil json_response["createdAt"]
    assert_not_nil json_response["updatedAt"]
  end

  test "message updates include all required fields" do
    get "/api/messages/updates",
        params: { userId: @user.id },
        headers: { "Authorization" => "Bearer #{@token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body).first
    
    assert_not_nil json_response["id"]
    assert_not_nil json_response["conversationId"]
    assert_not_nil json_response["senderId"]
    assert_not_nil json_response["senderUsername"]
    assert_not_nil json_response["senderRole"]
    assert_not_nil json_response["content"]
    assert_not_nil json_response["timestamp"]
    assert_includes [true, false], json_response["isRead"]
  end
end