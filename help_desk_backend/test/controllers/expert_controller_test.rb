# source: generated by Claude.ai
# run in rails bash shell with:
#       rails test test/controllers/expert_controller_test.rb

require "test_helper"

class ExpertControllerTest < ActionDispatch::IntegrationTest
  def setup
    @expert = User.create!(username: "expert", password: "password123")
    @expert_profile = @expert.create_expert_profile(bio: "I'm an expert")
    @expert_token = JwtService.encode(@expert)
    
    @user = User.create!(username: "user", password: "password123")
    @user_token = JwtService.encode(@user)
    
    @waiting_conversation = Conversation.create!(
      title: "Waiting Conversation",
      initiator: @user,
      status: "waiting"
    )
  end

  # Queue tests
  test "GET /expert/queue returns waiting and assigned conversations" do
    # Create another waiting conversation
    waiting_conv2 = Conversation.create!(
      title: "Another Waiting",
      initiator: @user,
      status: "waiting"
    )
    
    # Create an assigned conversation
    assigned_conv = Conversation.create!(
      title: "Assigned",
      initiator: @user,
      status: "active",
      assigned_expert: @expert
    )
    
    get "/expert/queue",
        headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    assert_equal 2, json_response["waitingConversations"].length
    assert_equal 1, json_response["assignedConversations"].length
  end

  test "GET /expert/queue requires authentication" do
    get "/expert/queue"
    assert_response :unauthorized
  end

  test "GET /expert/queue requires expert profile" do
    # This shouldn't happen since all users auto-get expert profiles,
    # but we test the guard anyway
    @expert.expert_profile.destroy
    
    get "/expert/queue",
        headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :forbidden
  end

  test "GET /expert/queue orders waiting conversations by created_at" do
    conv1 = Conversation.create!(
      title: "First",
      initiator: @user,
      status: "waiting",
      created_at: 3.hours.ago
    )
    
    conv2 = Conversation.create!(
      title: "Second",
      initiator: @user,
      status: "waiting",
      created_at: 1.hour.ago
    )
    
    get "/expert/queue",
        headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    waiting = json_response["waitingConversations"]
    
    # Oldest first
    assert_equal "First", waiting[0]["title"]
    assert_equal "Second", waiting[1]["title"]
  end

  test "GET /expert/queue orders assigned conversations by last_message_at" do
    conv1 = Conversation.create!(
      title: "Conv1",
      initiator: @user,
      status: "active",
      assigned_expert: @expert,
      last_message_at: 3.hours.ago
    )
    
    conv2 = Conversation.create!(
      title: "Conv2",
      initiator: @user,
      status: "active",
      assigned_expert: @expert,
      last_message_at: 1.hour.ago
    )
    
    get "/expert/queue",
        headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    assigned = json_response["assignedConversations"]
    
    # Most recent first
    assert_equal "Conv2", assigned[0]["title"]
    assert_equal "Conv1", assigned[1]["title"]
  end

  # Claim tests
  test "POST /expert/conversations/:id/claim assigns expert to conversation" do
    post "/expert/conversations/#{@waiting_conversation.id}/claim",
         headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :ok
    
    @waiting_conversation.reload
    assert_equal @expert.id, @waiting_conversation.assigned_expert_id
    assert_equal "active", @waiting_conversation.status
  end

  test "POST /expert/conversations/:id/claim creates expert assignment record" do
    assert_difference 'ExpertAssignment.count', 1 do
      post "/expert/conversations/#{@waiting_conversation.id}/claim",
           headers: { "Authorization" => "Bearer #{@expert_token}" }
    end
    
    assignment = ExpertAssignment.last
    assert_equal @waiting_conversation.id, assignment.conversation_id
    assert_equal @expert.id, assignment.expert_id
    assert_equal "active", assignment.status
  end

  test "POST /expert/conversations/:id/claim fails if already assigned" do
    other_expert = User.create!(username: "other_expert", password: "password123")
    other_expert.create_expert_profile(bio: "I'm an expert")
    @waiting_conversation.assign_expert(other_expert)
    
    post "/expert/conversations/#{@waiting_conversation.id}/claim",
         headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :unprocessable_entity
    json_response = JSON.parse(response.body)
    assert_equal "Conversation is already assigned to an expert", json_response["error"]
  end

  test "POST /expert/conversations/:id/claim requires authentication" do
    post "/expert/conversations/#{@waiting_conversation.id}/claim"
    assert_response :unauthorized
  end

  test "POST /expert/conversations/:id/claim returns 404 for non-existent conversation" do
    post "/expert/conversations/99999/claim",
         headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :not_found
  end

  # Unclaim tests
  test "POST /expert/conversations/:id/unclaim unassigns expert from conversation" do
    @waiting_conversation.assign_expert(@expert)
    
    post "/expert/conversations/#{@waiting_conversation.id}/unclaim",
         headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :ok
    
    @waiting_conversation.reload
    assert_nil @waiting_conversation.assigned_expert_id
    assert_equal "waiting", @waiting_conversation.status
  end

  test "POST /expert/conversations/:id/unclaim resolves expert assignment" do
    @waiting_conversation.assign_expert(@expert)
    assignment = ExpertAssignment.create!(
      conversation: @waiting_conversation,
      expert: @expert
    )
    
    post "/expert/conversations/#{@waiting_conversation.id}/unclaim",
         headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :ok
    
    assignment.reload
    assert_equal "resolved", assignment.status
    assert_not_nil assignment.resolved_at
  end

  test "POST /expert/conversations/:id/unclaim fails if not assigned to user" do
    other_expert = User.create!(username: "other_expert", password: "password123")
    other_expert.create_expert_profile(bio: "I'm an expert")
    @waiting_conversation.assign_expert(other_expert)
    
    post "/expert/conversations/#{@waiting_conversation.id}/unclaim",
         headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :forbidden
    json_response = JSON.parse(response.body)
    assert_equal "You are not assigned to this conversation", json_response["error"]
  end

  test "POST /expert/conversations/:id/unclaim requires authentication" do
    post "/expert/conversations/#{@waiting_conversation.id}/unclaim"
    assert_response :unauthorized
  end

  # Profile tests
  test "GET /expert/profile returns expert profile" do
    @expert_profile.update(bio: "Rails expert", knowledge_base_links: ["https://example.com"])
    
    get "/expert/profile",
        headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    assert_equal @expert_profile.id.to_s, json_response["id"]
    assert_equal @expert.id.to_s, json_response["userId"]
    assert_equal "Rails expert", json_response["bio"]
    assert_equal ["https://example.com"], json_response["knowledgeBaseLinks"]
  end

  test "GET /expert/profile requires authentication" do
    get "/expert/profile"
    assert_response :unauthorized
  end

  test "PUT /expert/profile updates profile" do
    put "/expert/profile",
        params: {
          bio: "Updated bio",
          knowledge_base_links: ["https://rails.org", "https://guides.rubyonrails.org"]
        },
        headers: { "Authorization" => "Bearer #{@expert_token}" },
        as: :json
    
    assert_response :ok
    
    @expert_profile.reload
    assert_equal "Updated bio", @expert_profile.bio
    assert_equal 2, @expert_profile.knowledge_base_links.length
  end

  test "PUT /expert/profile requires authentication" do
    put "/expert/profile",
        params: { bio: "Test" },
        as: :json
    
    assert_response :unauthorized
  end

  # Assignment history tests
  test "GET /expert/assignments/history returns expert's assignments" do
    conv1 = Conversation.create!(title: "Conv1", initiator: @user)
    conv1.assign_expert(@expert)
    assignment1 = ExpertAssignment.create!(conversation: conv1, expert: @expert)
    
    conv2 = Conversation.create!(title: "Conv2", initiator: @user)
    conv2.assign_expert(@expert)
    assignment2 = ExpertAssignment.create!(conversation: conv2, expert: @expert)
    assignment2.resolve!
    
    get "/expert/assignments/history",
        headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    assert_response :ok
    json_response = JSON.parse(response.body)
    
    assert_equal 2, json_response.length
  end

  test "GET /expert/assignments/history orders by assigned_at desc" do
    conv1 = Conversation.create!(title: "Conv1", initiator: @user)
    conv1.assign_expert(@expert)
    assignment1 = ExpertAssignment.create!(
      conversation: conv1,
      expert: @expert,
      assigned_at: 2.hours.ago
    )
    
    conv2 = Conversation.create!(title: "Conv2", initiator: @user)
    conv2.assign_expert(@expert)
    assignment2 = ExpertAssignment.create!(
      conversation: conv2,
      expert: @expert,
      assigned_at: 1.hour.ago
    )
    
    get "/expert/assignments/history",
        headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    json_response = JSON.parse(response.body)
    
    # Most recent first
    assert_equal assignment2.id.to_s, json_response[0]["id"]
    assert_equal assignment1.id.to_s, json_response[1]["id"]
  end

  test "GET /expert/assignments/history requires authentication" do
    get "/expert/assignments/history"
    assert_response :unauthorized
  end

  # Response format tests
  test "assignment response includes all required fields" do
    conv = Conversation.create!(title: "Test", initiator: @user)
    conv.assign_expert(@expert)
    assignment = ExpertAssignment.create!(conversation: conv, expert: @expert)
    assignment.resolve!
    
    get "/expert/assignments/history",
        headers: { "Authorization" => "Bearer #{@expert_token}" }
    
    json_response = JSON.parse(response.body).first
    
    assert_not_nil json_response["id"]
    assert_not_nil json_response["conversationId"]
    assert_not_nil json_response["expertId"]
    assert_not_nil json_response["status"]
    assert_not_nil json_response["assignedAt"]
    assert_not_nil json_response["resolvedAt"]
    assert_nil json_response["rating"]  # Not implemented
  end
end